/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.ops.function;

import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableBiMap;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Function;

import org.scijava.ops.OpService;
import org.scijava.ops.types.Nil;
import org.scijava.param.Mutable;
import org.scijava.util.Types;

/**
 * Container class for
 * higher-<a href="https://en.wikipedia.org/wiki/Arity">arity</a>
 * {@link Function}-style functional interfaces&mdash;i.e. with functional
 * method {@code apply} with a number of arguments corresponding to the arity.
 * <ul>
 * <li>For 0-arity (nullary) functions, use {@link Producer} (and notice the
 * functional method there is named {@link Producer\#create()}).</li>
 * <li>For 1-arity (unary) functions, use {@link Function}.</li>
 * <li>For 2-arity (binary) functions, use {@link BiFunction}.</li>
 * </ul>
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class Functions {

	private Functions() {
		// NB: Prevent instantiation of utility class.
	}

	// -- BEGIN TEMP --

	/**
	 * All known function types and their arities. The entries are sorted by arity,
	 * i.e., the {@code i}-th entry has an arity of {@code i}.
	 */
	public static final BiMap<Class<?>, Integer> ALL_FUNCTIONS;

	static {
		final Map<Class<?>, Integer> functions = new HashMap<>(10);
		functions.put(Producer.class, 0);
		functions.put(Function.class, 1);
		functions.put(BiFunction.class, 2);
		functions.put(Functions.Arity3.class, 3);
		functions.put(Functions.Arity4.class, 4);
		ALL_FUNCTIONS = ImmutableBiMap.copyOf(functions);
	}

	/**
	 * @return {@code true} if the given type is a {@link #ALL_FUNCTIONS known}
	 *         function type, {@code false} otherwise.<br>
	 *         Note that only the type itself and not its type hierarchy is
	 *         considered.
	 * @throws NullPointerException
	 *             If {@code type} is {@code null}.
	 */
	public static boolean isFunction(Type type) {
		return ALL_FUNCTIONS.containsKey(Types.raw(type));
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static <O> Producer<O> match(final OpService ops, final String opName, final Nil<O> outType) {
		final Type specialType = Types.parameterize(Producer.class, //
			new Type[] { outType.getType() });
		return (Producer) ops.findOp( //
				opName, //
				Nil.of(specialType), //
				new Nil[] {  }, //
				outType);
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static <I, O> Function<I, O> match(final OpService ops, final String opName, final Nil<I> inType, final Nil<O> outType) {
		final Type specialType = Types.parameterize(Function.class, //
			new Type[] { inType.getType(), outType.getType() });
		return (Function) ops.findOp( //
				opName, //
				Nil.of(specialType), //
				new Nil[] { inType }, //
				outType);
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static <I1, I2, O> BiFunction<I1, I2, O> match(final OpService ops, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<O> outType) {
		final Type specialType = Types.parameterize(BiFunction.class, //
			new Type[] { in1Type.getType(), in2Type.getType(), outType.getType() });
		return (BiFunction) ops.findOp( //
				opName, //
				Nil.of(specialType), //
				new Nil[] { in1Type, in2Type }, //
				outType);
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static <I1, I2, I3, O> Functions.Arity3<I1, I2, I3, O> match(final OpService ops, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<O> outType) {
		final Type specialType = Types.parameterize(Functions.Arity3.class, //
			new Type[] { in1Type.getType(), in2Type.getType(), in3Type.getType(), outType.getType() });
		return (Functions.Arity3) ops.findOp( //
				opName, //
				Nil.of(specialType), //
				new Nil[] { in1Type, in2Type, in3Type }, //
				outType);
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static <I1, I2, I3, I4, O> Functions.Arity4<I1, I2, I3, I4, O> match(final OpService ops, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<O> outType) {
		final Type specialType = Types.parameterize(Functions.Arity4.class, //
			new Type[] { in1Type.getType(), in2Type.getType(), in3Type.getType(), in4Type.getType(), outType.getType() });
		return (Functions.Arity4) ops.findOp( //
				opName, //
				Nil.of(specialType), //
				new Nil[] { in1Type, in2Type, in3Type, in4Type }, //
				outType);
	}



	/**
	 * A 3-arity specialization of {@link Function}.
	 *
	 * @param <I1>
	 *            the type of argument 1 to the function
	 * @param <I2>
	 *            the type of argument 2 to the function
	 * @param <I3>
	 *            the type of argument 3 to the function
	 * @param <O>
	 *            the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity3<I1, I2, I3, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1
		 *            function argument 1
		 * @param in2
		 *            function argument 2
		 * @param in3
		 *            function argument 3
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3);

		/**
		 * Returns a composed function that first applies this function to its input,
		 * and then applies the {@code after} function to the result. If evaluation of
		 * either function throws an exception, it is relayed to the caller of the
		 * composed function.
		 *
		 * @param <O2>
		 *            the type of output of the {@code after} function, and of the
		 *            composed function
		 * @param after
		 *            the function to apply after this function is applied
		 * @return a composed function that first applies this function and then applies
		 *         the {@code after} function
		 * @throws NullPointerException
		 *             if after is null
		 */
		default <O2> Arity3<I1, I2, I3, O2> andThen(Function<? super O, ? extends O2> after) {
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3) -> after.apply(apply(in1, in2, in3));
		}
	}
	
	/**
	 * A 4-arity specialization of {@link Function}.
	 *
	 * @param <I1>
	 *            the type of argument 1 to the function
	 * @param <I2>
	 *            the type of argument 2 to the function
	 * @param <I3>
	 *            the type of argument 3 to the function
	 * @param <I4>
	 *            the type of argument 4 to the function
	 * @param <O>
	 *            the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity4<I1, I2, I3, I4, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1
		 *            function argument 1
		 * @param in2
		 *            function argument 2
		 * @param in3
		 *            function argument 3
		 * @param in4
		 *            function argument 4
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4);

		/**
		 * Returns a composed function that first applies this function to its input,
		 * and then applies the {@code after} function to the result. If evaluation of
		 * either function throws an exception, it is relayed to the caller of the
		 * composed function.
		 *
		 * @param <O2>
		 *            the type of output of the {@code after} function, and of the
		 *            composed function
		 * @param after
		 *            the function to apply after this function is applied
		 * @return a composed function that first applies this function and then applies
		 *         the {@code after} function
		 * @throws NullPointerException
		 *             if after is null
		 */
		default <O2> Arity4<I1, I2, I3, I4, O2> andThen(Function<? super O, ? extends O2> after) {
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4) -> after.apply(apply(in1, in2, in3, in4));
		}
	}
	
}
