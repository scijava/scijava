/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.ops.function;

import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableBiMap;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.Function;

import org.scijava.function.Functions;
import org.scijava.function.Producer;
import org.scijava.ops.OpEnvironment;
import org.scijava.ops.hints.Hints;
import org.scijava.types.Nil;
import org.scijava.types.Types;

/**
 * Utility class designed to match {@code Function}s of various arities.
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class FunctionUtils {

	private FunctionUtils() {
		// NB: Prevent instantiation of utility class.
	}

	/**
	 * All known function types and their arities. The entries are sorted by
	 * arity, i.e., the {@code i}-th entry has an arity of {@code i}.
	 */
	public static final BiMap<Integer, Class<?>> ALL_FUNCTIONS;

	static {
		final Map<Integer, Class<?>> functions = new HashMap<>(10);
#foreach($arity in [0..$maxArity])
		functions.put($arity, ${functionArity.call($arity)}.class);
#end
		ALL_FUNCTIONS = ImmutableBiMap.copyOf(functions);
	}

	/**
	 * @return {@code true} if the given type is a {@link #ALL_FUNCTIONS known}
	 *         function type, {@code false} otherwise.<br>
	 *         Note that only the type itself and not its type hierarchy is
	 *         considered.
	 * @throws NullPointerException If {@code type} is {@code null}.
	 */
	public static boolean isFunction(Type type) {
		return ALL_FUNCTIONS.containsValue(Types.raw(type));
	}

#foreach($arity in [0..$maxArity])
	@SuppressWarnings({ "unchecked" })
	public static $generics.call($arity) $functionArity.call($arity)$generics.call($arity) match(final OpEnvironment env, final String opName, $matchParams.call($arity))
	{
		return matchHelper(env, opName, ${functionArity.call($arity)}.class, $nilArgs.call($arity));
	}

#end
#foreach($arity in [0..$maxArity])
	@SuppressWarnings({ "unchecked" })
	public static $generics.call($arity) $functionArity.call($arity)$generics.call($arity) match(final OpEnvironment env, final String opName, $matchParams.call($arity), final Hints hints)
	{
		return matchHelper(env, opName, hints, ${functionArity.call($arity)}.class, $nilArgs.call($arity));
	}

#end
	@SuppressWarnings({ "unchecked" })
	public static <O, T> Functions.ArityN<O> matchN(final OpEnvironment env,
		final String opName, final Nil<O> outType, final Nil<?>... inTypes)
	{
		Object op = matchHelper(env, opName, ALL_FUNCTIONS.get(inTypes.length),
			outType, inTypes);
		if (op instanceof Producer) {
			return Functions.nary((Producer<O>) op);
		}
#set($maxMinusOne = $maxArity - 1)
#foreach($arity in [1..$maxMinusOne])
		else if (op instanceof $functionArity.call($arity)) {
			return Functions.nary(($functionArity.call($arity)$objectGenerics.call($arity)) op);
		}
#end
		return Functions.nary(($functionArity.call($maxArity)$objectGenerics.call($maxArity)) op);
	}

	@SuppressWarnings({ "unchecked" })
	private static <T> T matchHelper(final OpEnvironment env, final String opName,
		final Class<T> opClass, final Nil<?> outType, final Nil<?>... inTypes)
	{
		final Type[] types = new Type[inTypes.length + 1];
		for (int i = 0; i < inTypes.length; i++)
			types[i] = inTypes[i].getType();
		types[types.length - 1] = outType.getType();
		final Type specialType = Types.parameterize(opClass, types);
		return (T) env.op(opName, Nil.of(specialType), inTypes, outType);
	}

	@SuppressWarnings({ "unchecked" })
	private static <T> T matchHelper(final OpEnvironment env, final String opName, final Hints hints,
		final Class<T> opClass, final Nil<?> outType, final Nil<?>... inTypes)
	{
		final Type[] types = new Type[inTypes.length + 1];
		for (int i = 0; i < inTypes.length; i++)
			types[i] = inTypes[i].getType();
		types[types.length - 1] = outType.getType();
		final Type specialType = Types.parameterize(opClass, types);
		return (T) env.op(opName, Nil.of(specialType), inTypes, outType, hints);
	}

}
