/*
 * #%L
 * SciJava Operations: a framework for reusable algorithms.
 * %%
 * Copyright (C) 2016 - 2019 SciJava Ops developers.
 * %%
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 * #L%
 */

/*
* This is autogenerated source code -- DO NOT EDIT. Instead, edit the
* corresponding template in templates/ and rerun bin/generate.groovy.
*/

package org.scijava.ops.core.builder;

import java.lang.ref.WeakReference;
import java.lang.reflect.Type;
import java.util.function.BiFunction;
import java.util.function.Function;

import org.scijava.ops.OpService;
import org.scijava.ops.function.Computers;
import org.scijava.ops.function.Functions;
import org.scijava.ops.function.Inplaces;
import org.scijava.ops.function.Producer;
import org.scijava.ops.types.Nil;
import org.scijava.ops.types.TypeService;
import org.scijava.util.Types;

/**
 * Convenience class for looking up and/or executing ops using a builder
 * pattern.
 * <p>
 * TODO: Examples
 * </p>
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public class OpBuilder {

	private final OpService ops;
	private final String opName;

	public OpBuilder(final OpService ops, final String opName) {
		this.ops = ops;
		this.opName = opName;
	}

	/** Specifies the op accepts no inputs&mdash;i.e., a nullary op. */
	public Arity0_OU input() {
		return new Arity0_OU();
	}

	/** Specifies 1 input by value. */
	public <I1> Arity1_IV_OU<I1> input(final I1 in1) {
		return new Arity1_IV_OU<>(in1);
	}

	/** Specifies 1 input by raw type. */
	public <I1> Arity1_IT_OU<I1> inType(final Class<I1> in1Class) {
		return inType(Nil.of(in1Class));
	}

	/** Specifies 1 input by generic type. */
	public <I1> Arity1_IT_OU<I1> inType(final Nil<I1> in1Type) {
		return new Arity1_IT_OU<>(in1Type);
	}

	/** Specifies 2 input by value. */
	public <I1, I2> Arity2_IV_OU<I1, I2> input(final I1 in1, final I2 in2) {
		return new Arity2_IV_OU<>(in1, in2);
	}

	/** Specifies 2 input by raw type. */
	public <I1, I2> Arity2_IT_OU<I1, I2> inType(final Class<I1> in1Class, final Class<I2> in2Class) {
		return inType(Nil.of(in1Class), Nil.of(in2Class));
	}

	/** Specifies 2 input by generic type. */
	public <I1, I2> Arity2_IT_OU<I1, I2> inType(final Nil<I1> in1Type, final Nil<I2> in2Type) {
		return new Arity2_IT_OU<>(in1Type, in2Type);
	}

	/** Specifies 3 input by value. */
	public <I1, I2, I3> Arity3_IV_OU<I1, I2, I3> input(final I1 in1, final I2 in2, final I3 in3) {
		return new Arity3_IV_OU<>(in1, in2, in3);
	}

	/** Specifies 3 input by raw type. */
	public <I1, I2, I3> Arity3_IT_OU<I1, I2, I3> inType(final Class<I1> in1Class, final Class<I2> in2Class,
			final Class<I3> in3Class) {
		return inType(Nil.of(in1Class), Nil.of(in2Class), Nil.of(in3Class));
	}

	/** Specifies 3 input by generic type. */
	public <I1, I2, I3> Arity3_IT_OU<I1, I2, I3> inType(final Nil<I1> in1Type, final Nil<I2> in2Type,
			final Nil<I3> in3Type) {
		return new Arity3_IT_OU<>(in1Type, in2Type, in3Type);
	}

	// -- Helper methods --

	@SuppressWarnings({ "unchecked" })
	private <T> Nil<T> type(final WeakReference<T> obj) {
		return (Nil<T>) Nil.of(ops.context().service(TypeService.class).reify(obj.get()));
	}

	/*
	 * -- HELPER CLASSES --
	 * 
	 * For each arity, there are multiple conditions: * Input TYPES are given (IT)
	 * 1) The output is unspecified (OU): a) matchable: Function, Inplace b)
	 * runnable: none 2) The output type is given (OT): a) matchable: Function,
	 * Computer b) runnable: none
	 * 
	 * * Input VALUES are given (IV) (N.B. this case applies for Arity0): 1) The
	 * output is unspecified (OU): a) matchable: Function, Inplace b) runnable:
	 * apply, mutate 2) The output type is given (OT): a) matchable: Function,
	 * Computer b) runnable: apply 3) The output value is given (OV): a) matchable:
	 * Computer b) runnable: compute
	 */

	/**
	 * Builder with arity 0, output unspecified.
	 *
	 * @author Curtis Rueden
	 */
	public final class Arity0_OU {

		public <O> Arity0_OV<O> output(final O out) {
			return new Arity0_OV<>(out);
		}

		public <O> Arity0_OT<O> outType(final Class<O> outType) {
			return outType(Nil.of(outType));
		}

		public <O> Arity0_OT<O> outType(final Nil<O> outType) {
			return new Arity0_OT<>(outType);
		}

		public Producer<?> producer() {
			final Nil<Producer<Object>> specialType = new Nil<Producer<Object>>() {
				@Override
				public Type getType() {
					return Types.parameterize(Producer.class, new Type[] { Object.class });
				}
			};
			return ops.findOp(opName, specialType, new Nil<?>[0], Nil.of(Object.class));
		}

		public Object create() {
			return producer().create();
		}
	}

	/**
	 * Builder with arity 0, output type given.
	 *
	 * @author Curtis Rueden
	 * @param <O>
	 *            The type of the output.
	 */
	public final class Arity0_OT<O> {

		private final Nil<O> outType;

		public Arity0_OT(final Nil<O> outType) {
			this.outType = outType;
		}

		public Producer<O> producer() {
			final Nil<Producer<O>> specialType = new Nil<Producer<O>>() {
				@Override
				public Type getType() {
					return Types.parameterize(Producer.class, new Type[] { outType.getType() });
				}
			};
			return ops.findOp(opName, specialType, new Nil<?>[0], outType);
		}

		public Computers.Arity0<O> computer() {
			return Computers.match(ops, opName, outType);
		}

		public O create() {
			return producer().create();
		}

	}

	/**
	 * Builder with arity 0, output value given.
	 *
	 * @author Curtis Rueden
	 * @param <O>
	 *            The type of the output.
	 */
	public final class Arity0_OV<O> {

		private final WeakReference<O> out;

		public Arity0_OV(final O out) {
			this.out = new WeakReference<>(out);
		}

		public Computers.Arity0<O> computer() {
			return Computers.match(ops, opName, type(out));
		}

		public void compute() {
			computer().compute(out.get());
		}

	}

	/**
	 * Builder with arity 1, input type given, output type given.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <O>
	 *            The type of the output.
	 */
	public final class Arity1_IT_OT<I1, O> {

		private final Nil<I1> in1Type;
		private final Nil<O> outType;

		public Arity1_IT_OT(final Nil<I1> in1Type, final Nil<O> outType) {
			this.in1Type = in1Type;
			this.outType = outType;
		}

		public Function<I1, O> function() {
			return Functions.match(ops, opName, in1Type, outType);
		}

		public Computers.Arity1<I1, O> computer() {
			return Computers.match(ops, opName, in1Type, outType);
		}

		public Inplaces.Arity1<I1> inplace() {
			return Inplaces.match(ops, opName, in1Type);
		}

	}

	/**
	 * Builder with arity 1, input type given, output unspecified.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 */
	public final class Arity1_IT_OU<I1> {

		private final Nil<I1> in1Type;

		public Arity1_IT_OU(final Nil<I1> in1Type) {
			this.in1Type = in1Type;
		}

		public <O> Arity1_IT_OT<I1, O> outType(final Class<O> outType) {
			return outType(Nil.of(outType));
		}

		public <O> Arity1_IT_OT<I1, O> outType(final Nil<O> outType) {
			return new Arity1_IT_OT<>(in1Type, outType);
		}

		public Function<I1, ?> function() {
			return Functions.match(ops, opName, in1Type, Nil.of(Object.class));
		}

		public Inplaces.Arity1<I1> inplace() {
			return Inplaces.match(ops, opName, in1Type);
		}
	}

	/**
	 * Builder with arity 1, input value given, output type given.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <O>
	 *            The type of the output.
	 */
	public final class Arity1_IV_OT<I1, O> {

		private final WeakReference<I1> in1;
		private final Nil<O> outType;

		public Arity1_IV_OT(final I1 in1, final Nil<O> outType) {
			this.in1 = new WeakReference<>(in1);
			this.outType = outType;
		}

		public Function<I1, O> function() {
			return Functions.match(ops, opName, type(in1), outType);
		}

		public Computers.Arity1<I1, O> computer() {
			return Computers.match(ops, opName, type(in1), outType);
		}

		public O apply() {
			return function().apply(in1.get());
		}
	}

	/**
	 * Builder with arity 1, input value given, output unspecified.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 */
	public final class Arity1_IV_OU<I1> {

		private final WeakReference<I1> in1;

		public Arity1_IV_OU(final I1 in1) {
			this.in1 = new WeakReference<>(in1);
		}

		public <O> Arity1_IV_OV<I1, O> output(final O out) {
			return new Arity1_IV_OV<>(in1.get(), out);
		}

		public <O> Arity1_IV_OT<I1, O> outType(final Class<O> outType) {
			return outType(Nil.of(outType));
		}

		public <O> Arity1_IV_OT<I1, O> outType(final Nil<O> outType) {
			return new Arity1_IV_OT<>(in1.get(), outType);
		}

		public Function<I1, ?> function() {
			return Functions.match(ops, opName, type(in1), Nil.of(Object.class));
		}

		public Inplaces.Arity1<I1> inplace() {
			return Inplaces.match(ops, opName, type(in1));
		}

		public Object apply() {
			return function().apply(in1.get());
		}

		public void mutate() {
			inplace().mutate(in1.get());
		}
	}

	/**
	 * Builder with arity 1, input value given, output value given.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 */
	public final class Arity1_IV_OV<I1, O> {

		private final WeakReference<I1> in1;
		private final WeakReference<O> out;

		public Arity1_IV_OV(final I1 in1, final O out) {
			this.in1 = new WeakReference<>(in1);
			this.out = new WeakReference<>(out);
		}

		public Computers.Arity1<I1, O> computer() {
			return Computers.match(ops, opName, type(in1), type(out));
		}

		public void compute() {
			computer().compute(in1.get(), out.get());
		}

	}

	/**
	 * Builder with arity 2, input type given, output type given.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <I2>
	 *            The type of input 2.
	 * @param <O>
	 *            The type of the output.
	 */
	public final class Arity2_IT_OT<I1, I2, O> {

		private final Nil<I1> in1Type;
		private final Nil<I2> in2Type;
		private final Nil<O> outType;

		public Arity2_IT_OT(final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<O> outType) {
			this.in1Type = in1Type;
			this.in2Type = in2Type;
			this.outType = outType;
		}

		public BiFunction<I1, I2, O> function() {
			return Functions.match(ops, opName, in1Type, in2Type, outType);
		}

		public Computers.Arity2<I1, I2, O> computer() {
			return Computers.match(ops, opName, in1Type, in2Type, outType);
		}

		public Inplaces.Arity2_1<I1, I2> inplace1() {
			return Inplaces.match1(ops, opName, in1Type, in2Type);
		}

		public Inplaces.Arity2_2<I1, I2> inplace2() {
			return Inplaces.match2(ops, opName, in1Type, in2Type);
		}

	}

	/**
	 * Builder with arity 2, input type given, output unspecified.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <I2>
	 *            The type of input 2.
	 */
	public final class Arity2_IT_OU<I1, I2> {

		private final Nil<I1> in1Type;
		private final Nil<I2> in2Type;

		public Arity2_IT_OU(final Nil<I1> in1Type, final Nil<I2> in2Type) {
			this.in1Type = in1Type;
			this.in2Type = in2Type;
		}

		public <O> Arity2_IT_OT<I1, I2, O> outType(final Class<O> outType) {
			return outType(Nil.of(outType));
		}

		public <O> Arity2_IT_OT<I1, I2, O> outType(final Nil<O> outType) {
			return new Arity2_IT_OT<>(in1Type, in2Type, outType);
		}

		public BiFunction<I1, I2, ?> function() {
			return Functions.match(ops, opName, in1Type, in2Type, Nil.of(Object.class));
		}

		public Inplaces.Arity2_1<I1, I2> inplace1() {
			return Inplaces.match1(ops, opName, in1Type, in2Type);
		}

		public Inplaces.Arity2_2<I1, I2> inplace2() {
			return Inplaces.match2(ops, opName, in1Type, in2Type);
		}
	}

	/**
	 * Builder with arity 2, input value given, output type given.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <I2>
	 *            The type of input 2.
	 * @param <O>
	 *            The type of the output.
	 */
	public final class Arity2_IV_OT<I1, I2, O> {

		private final WeakReference<I1> in1;
		private final WeakReference<I2> in2;
		private final Nil<O> outType;

		public Arity2_IV_OT(final I1 in1, final I2 in2, final Nil<O> outType) {
			this.in1 = new WeakReference<>(in1);
			this.in2 = new WeakReference<>(in2);
			this.outType = outType;
		}

		public BiFunction<I1, I2, O> function() {
			return Functions.match(ops, opName, type(in1), type(in2), outType);
		}

		public Computers.Arity2<I1, I2, O> computer() {
			return Computers.match(ops, opName, type(in1), type(in2), outType);
		}

		public O apply() {
			return function().apply(in1.get(), in2.get());
		}
	}

	/**
	 * Builder with arity 2, input value given, output unspecified.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <I2>
	 *            The type of input 2.
	 */
	public final class Arity2_IV_OU<I1, I2> {

		private final WeakReference<I1> in1;
		private final WeakReference<I2> in2;

		public Arity2_IV_OU(final I1 in1, final I2 in2) {
			this.in1 = new WeakReference<>(in1);
			this.in2 = new WeakReference<>(in2);
		}

		public <O> Arity2_IV_OV<I1, I2, O> output(final O out) {
			return new Arity2_IV_OV<>(in1.get(), in2.get(), out);
		}

		public <O> Arity2_IV_OT<I1, I2, O> outType(final Class<O> outType) {
			return outType(Nil.of(outType));
		}

		public <O> Arity2_IV_OT<I1, I2, O> outType(final Nil<O> outType) {
			return new Arity2_IV_OT<>(in1.get(), in2.get(), outType);
		}

		public BiFunction<I1, I2, ?> function() {
			return Functions.match(ops, opName, type(in1), type(in2), Nil.of(Object.class));
		}

		public Inplaces.Arity2_1<I1, I2> inplace1() {
			return Inplaces.match1(ops, opName, type(in1), type(in2));
		}

		public Inplaces.Arity2_2<I1, I2> inplace2() {
			return Inplaces.match2(ops, opName, type(in1), type(in2));
		}

		public Object apply() {
			return function().apply(in1.get(), in2.get());
		}

		public void mutate1() {
			inplace1().mutate(in1.get(), in2.get());
		}

		public void mutate2() {
			inplace2().mutate(in1.get(), in2.get());
		}
	}

	/**
	 * Builder with arity 2, input value given, output value given.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <I2>
	 *            The type of input 2.
	 */
	public final class Arity2_IV_OV<I1, I2, O> {

		private final WeakReference<I1> in1;
		private final WeakReference<I2> in2;
		private final WeakReference<O> out;

		public Arity2_IV_OV(final I1 in1, final I2 in2, final O out) {
			this.in1 = new WeakReference<>(in1);
			this.in2 = new WeakReference<>(in2);
			this.out = new WeakReference<>(out);
		}

		public Computers.Arity2<I1, I2, O> computer() {
			return Computers.match(ops, opName, type(in1), type(in2), type(out));
		}

		public void compute() {
			computer().compute(in1.get(), in2.get(), out.get());
		}

	}

	/**
	 * Builder with arity 3, input type given, output type given.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <I2>
	 *            The type of input 2.
	 * @param <I3>
	 *            The type of input 3.
	 * @param <O>
	 *            The type of the output.
	 */
	public final class Arity3_IT_OT<I1, I2, I3, O> {

		private final Nil<I1> in1Type;
		private final Nil<I2> in2Type;
		private final Nil<I3> in3Type;
		private final Nil<O> outType;

		public Arity3_IT_OT(final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<O> outType) {
			this.in1Type = in1Type;
			this.in2Type = in2Type;
			this.in3Type = in3Type;
			this.outType = outType;
		}

		public Functions.Arity3<I1, I2, I3, O> function() {
			return Functions.match(ops, opName, in1Type, in2Type, in3Type, outType);
		}

		public Computers.Arity3<I1, I2, I3, O> computer() {
			return Computers.match(ops, opName, in1Type, in2Type, in3Type, outType);
		}

		public Inplaces.Arity3_1<I1, I2, I3> inplace1() {
			return Inplaces.match1(ops, opName, in1Type, in2Type, in3Type);
		}

		public Inplaces.Arity3_2<I1, I2, I3> inplace2() {
			return Inplaces.match2(ops, opName, in1Type, in2Type, in3Type);
		}

		public Inplaces.Arity3_3<I1, I2, I3> inplace3() {
			return Inplaces.match3(ops, opName, in1Type, in2Type, in3Type);
		}

	}

	/**
	 * Builder with arity 3, input type given, output unspecified.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <I2>
	 *            The type of input 2.
	 * @param <I3>
	 *            The type of input 3.
	 */
	public final class Arity3_IT_OU<I1, I2, I3> {

		private final Nil<I1> in1Type;
		private final Nil<I2> in2Type;
		private final Nil<I3> in3Type;

		public Arity3_IT_OU(final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type) {
			this.in1Type = in1Type;
			this.in2Type = in2Type;
			this.in3Type = in3Type;
		}

		public <O> Arity3_IT_OT<I1, I2, I3, O> outType(final Class<O> outType) {
			return outType(Nil.of(outType));
		}

		public <O> Arity3_IT_OT<I1, I2, I3, O> outType(final Nil<O> outType) {
			return new Arity3_IT_OT<>(in1Type, in2Type, in3Type, outType);
		}

		public Functions.Arity3<I1, I2, I3, ?> function() {
			return Functions.match(ops, opName, in1Type, in2Type, in3Type, Nil.of(Object.class));
		}

		public Inplaces.Arity3_1<I1, I2, I3> inplace1() {
			return Inplaces.match1(ops, opName, in1Type, in2Type, in3Type);
		}

		public Inplaces.Arity3_2<I1, I2, I3> inplace2() {
			return Inplaces.match2(ops, opName, in1Type, in2Type, in3Type);
		}

		public Inplaces.Arity3_3<I1, I2, I3> inplace3() {
			return Inplaces.match3(ops, opName, in1Type, in2Type, in3Type);
		}
	}

	/**
	 * Builder with arity 3, input value given, output type given.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <I2>
	 *            The type of input 2.
	 * @param <I3>
	 *            The type of input 3.
	 * @param <O>
	 *            The type of the output.
	 */
	public final class Arity3_IV_OT<I1, I2, I3, O> {

		private final WeakReference<I1> in1;
		private final WeakReference<I2> in2;
		private final WeakReference<I3> in3;
		private final Nil<O> outType;

		public Arity3_IV_OT(final I1 in1, final I2 in2, final I3 in3, final Nil<O> outType) {
			this.in1 = new WeakReference<>(in1);
			this.in2 = new WeakReference<>(in2);
			this.in3 = new WeakReference<>(in3);
			this.outType = outType;
		}

		public Functions.Arity3<I1, I2, I3, O> function() {
			return Functions.match(ops, opName, type(in1), type(in2), type(in3), outType);
		}

		public Computers.Arity3<I1, I2, I3, O> computer() {
			return Computers.match(ops, opName, type(in1), type(in2), type(in3), outType);
		}

		public O apply() {
			return function().apply(in1.get(), in2.get(), in3.get());
		}
	}

	/**
	 * Builder with arity 3, input value given, output unspecified.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <I2>
	 *            The type of input 2.
	 * @param <I3>
	 *            The type of input 3.
	 */
	public final class Arity3_IV_OU<I1, I2, I3> {

		private final WeakReference<I1> in1;
		private final WeakReference<I2> in2;
		private final WeakReference<I3> in3;

		public Arity3_IV_OU(final I1 in1, final I2 in2, final I3 in3) {
			this.in1 = new WeakReference<>(in1);
			this.in2 = new WeakReference<>(in2);
			this.in3 = new WeakReference<>(in3);
		}

		public <O> Arity3_IV_OV<I1, I2, I3, O> output(final O out) {
			return new Arity3_IV_OV<>(in1.get(), in2.get(), in3.get(), out);
		}

		public <O> Arity3_IV_OT<I1, I2, I3, O> outType(final Class<O> outType) {
			return outType(Nil.of(outType));
		}

		public <O> Arity3_IV_OT<I1, I2, I3, O> outType(final Nil<O> outType) {
			return new Arity3_IV_OT<>(in1.get(), in2.get(), in3.get(), outType);
		}

		public Functions.Arity3<I1, I2, I3, ?> function() {
			return Functions.match(ops, opName, type(in1), type(in2), type(in3), Nil.of(Object.class));
		}

		public Inplaces.Arity3_1<I1, I2, I3> inplace1() {
			return Inplaces.match1(ops, opName, type(in1), type(in2), type(in3));
		}

		public Inplaces.Arity3_2<I1, I2, I3> inplace2() {
			return Inplaces.match2(ops, opName, type(in1), type(in2), type(in3));
		}

		public Inplaces.Arity3_3<I1, I2, I3> inplace3() {
			return Inplaces.match3(ops, opName, type(in1), type(in2), type(in3));
		}

		public Object apply() {
			return function().apply(in1.get(), in2.get(), in3.get());
		}

		public void mutate1() {
			inplace1().mutate(in1.get(), in2.get(), in3.get());
		}

		public void mutate2() {
			inplace2().mutate(in1.get(), in2.get(), in3.get());
		}

		public void mutate3() {
			inplace3().mutate(in1.get(), in2.get(), in3.get());
		}
	}

	/**
	 * Builder with arity 3, input value given, output value given.
	 *
	 * @author Curtis Rueden
	 * @param <I1>
	 *            The type of input 1.
	 * @param <I2>
	 *            The type of input 2.
	 * @param <I3>
	 *            The type of input 3.
	 */
	public final class Arity3_IV_OV<I1, I2, I3, O> {

		private final WeakReference<I1> in1;
		private final WeakReference<I2> in2;
		private final WeakReference<I3> in3;
		private final WeakReference<O> out;

		public Arity3_IV_OV(final I1 in1, final I2 in2, final I3 in3, final O out) {
			this.in1 = new WeakReference<>(in1);
			this.in2 = new WeakReference<>(in2);
			this.in3 = new WeakReference<>(in3);
			this.out = new WeakReference<>(out);
		}

		public Computers.Arity3<I1, I2, I3, O> computer() {
			return Computers.match(ops, opName, type(in1), type(in2), type(in3), type(out));
		}

		public void compute() {
			computer().compute(in1.get(), in2.get(), in3.get(), out.get());
		}

	}

}
