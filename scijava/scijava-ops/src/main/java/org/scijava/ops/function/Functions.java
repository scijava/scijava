/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.ops.function;

import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableBiMap;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Function;

import org.scijava.ops.OpEnvironment;
import org.scijava.ops.hints.Hints;
import org.scijava.types.Nil;
import org.scijava.types.Types;

/**
 * Container class for
 * higher-<a href="https://en.wikipedia.org/wiki/Arity">arity</a>
 * {@link Function}-style functional interfaces&mdash;i.e. with functional
 * method {@code apply} with a number of arguments corresponding to the arity.
 * <ul>
 * <li>For 0-arity (nullary) functions, use {@link Producer} (and notice the
 * functional method there is named {@link Producer\#create()}).</li>
 * <li>For 1-arity (unary) functions, use {@link Function}.</li>
 * <li>For 2-arity (binary) functions, use {@link BiFunction}.</li>
 * </ul>
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class Functions {

	private Functions() {
		// NB: Prevent instantiation of utility class.
	}

	// -- BEGIN TEMP --

	/**
	 * All known function types and their arities. The entries are sorted by
	 * arity, i.e., the {@code i}-th entry has an arity of {@code i}.
	 */
	public static final BiMap<Integer, Class<?>> ALL_FUNCTIONS;

	static {
		final Map<Integer, Class<?>> functions = new HashMap<>(10);
		functions.put(0, Producer.class);
		functions.put(1, Function.class);
		functions.put(2, BiFunction.class);
		functions.put(3, Functions.Arity3.class);
		functions.put(4, Functions.Arity4.class);
		functions.put(5, Functions.Arity5.class);
		functions.put(6, Functions.Arity6.class);
		functions.put(7, Functions.Arity7.class);
		functions.put(8, Functions.Arity8.class);
		functions.put(9, Functions.Arity9.class);
		functions.put(10, Functions.Arity10.class);
		functions.put(11, Functions.Arity11.class);
		functions.put(12, Functions.Arity12.class);
		functions.put(13, Functions.Arity13.class);
		functions.put(14, Functions.Arity14.class);
		functions.put(15, Functions.Arity15.class);
		functions.put(16, Functions.Arity16.class);
		ALL_FUNCTIONS = ImmutableBiMap.copyOf(functions);
	}

	/**
	 * @return {@code true} if the given type is a {@link #ALL_FUNCTIONS known}
	 *         function type, {@code false} otherwise.<br>
	 *         Note that only the type itself and not its type hierarchy is
	 *         considered.
	 * @throws NullPointerException If {@code type} is {@code null}.
	 */
	public static boolean isFunction(Type type) {
		return ALL_FUNCTIONS.containsKey(Types.raw(type));
	}

	@SuppressWarnings({ "unchecked" })
	public static <O> Producer<O> match(final OpEnvironment env, final String opName, final Nil<O> outType)
	{
		return matchHelper(env, opName, Producer.class, outType);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I, O> Function<I, O> match(final OpEnvironment env, final String opName, final Nil<I> inType, final Nil<O> outType)
	{
		return matchHelper(env, opName, Function.class, outType, inType);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, O> BiFunction<I1, I2, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, BiFunction.class, outType, in1Type, in2Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, O> Functions.Arity3<I1, I2, I3, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity3.class, outType, in1Type, in2Type, in3Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, O> Functions.Arity4<I1, I2, I3, I4, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity4.class, outType, in1Type, in2Type, in3Type, in4Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, O> Functions.Arity5<I1, I2, I3, I4, I5, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity5.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, O> Functions.Arity6<I1, I2, I3, I4, I5, I6, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity6.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, O> Functions.Arity7<I1, I2, I3, I4, I5, I6, I7, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity7.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, O> Functions.Arity8<I1, I2, I3, I4, I5, I6, I7, I8, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity8.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, O> Functions.Arity9<I1, I2, I3, I4, I5, I6, I7, I8, I9, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity9.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, O> Functions.Arity10<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity10.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, O> Functions.Arity11<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity11.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, O> Functions.Arity12<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<I12> in12Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity12.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type, in12Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, O> Functions.Arity13<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<I12> in12Type, final Nil<I13> in13Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity13.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type, in12Type, in13Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, O> Functions.Arity14<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<I12> in12Type, final Nil<I13> in13Type, final Nil<I14> in14Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity14.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type, in12Type, in13Type, in14Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, O> Functions.Arity15<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<I12> in12Type, final Nil<I13> in13Type, final Nil<I14> in14Type, final Nil<I15> in15Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity15.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type, in12Type, in13Type, in14Type, in15Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, O> Functions.Arity16<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<I12> in12Type, final Nil<I13> in13Type, final Nil<I14> in14Type, final Nil<I15> in15Type, final Nil<I16> in16Type, final Nil<O> outType)
	{
		return matchHelper(env, opName, Functions.Arity16.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type, in12Type, in13Type, in14Type, in15Type, in16Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <O> Producer<O> match(final OpEnvironment env, final String opName, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Producer.class, outType);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I, O> Function<I, O> match(final OpEnvironment env, final String opName, final Nil<I> inType, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Function.class, outType, inType);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, O> BiFunction<I1, I2, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, BiFunction.class, outType, in1Type, in2Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, O> Functions.Arity3<I1, I2, I3, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity3.class, outType, in1Type, in2Type, in3Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, O> Functions.Arity4<I1, I2, I3, I4, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity4.class, outType, in1Type, in2Type, in3Type, in4Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, O> Functions.Arity5<I1, I2, I3, I4, I5, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity5.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, O> Functions.Arity6<I1, I2, I3, I4, I5, I6, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity6.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, O> Functions.Arity7<I1, I2, I3, I4, I5, I6, I7, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity7.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, O> Functions.Arity8<I1, I2, I3, I4, I5, I6, I7, I8, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity8.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, O> Functions.Arity9<I1, I2, I3, I4, I5, I6, I7, I8, I9, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity9.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, O> Functions.Arity10<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity10.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, O> Functions.Arity11<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity11.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, O> Functions.Arity12<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<I12> in12Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity12.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type, in12Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, O> Functions.Arity13<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<I12> in12Type, final Nil<I13> in13Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity13.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type, in12Type, in13Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, O> Functions.Arity14<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<I12> in12Type, final Nil<I13> in13Type, final Nil<I14> in14Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity14.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type, in12Type, in13Type, in14Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, O> Functions.Arity15<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<I12> in12Type, final Nil<I13> in13Type, final Nil<I14> in14Type, final Nil<I15> in15Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity15.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type, in12Type, in13Type, in14Type, in15Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, O> Functions.Arity16<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, O> match(final OpEnvironment env, final String opName, final Nil<I1> in1Type, final Nil<I2> in2Type, final Nil<I3> in3Type, final Nil<I4> in4Type, final Nil<I5> in5Type, final Nil<I6> in6Type, final Nil<I7> in7Type, final Nil<I8> in8Type, final Nil<I9> in9Type, final Nil<I10> in10Type, final Nil<I11> in11Type, final Nil<I12> in12Type, final Nil<I13> in13Type, final Nil<I14> in14Type, final Nil<I15> in15Type, final Nil<I16> in16Type, final Nil<O> outType, final Hints hints)
	{
		return matchHelper(env, opName, hints, Functions.Arity16.class, outType, in1Type, in2Type, in3Type, in4Type, in5Type, in6Type, in7Type, in8Type, in9Type, in10Type, in11Type, in12Type, in13Type, in14Type, in15Type, in16Type);
	}

	@SuppressWarnings({ "unchecked" })
	public static <O, T> Functions.ArityN<O> matchN(final OpEnvironment env,
		final String opName, final Nil<O> outType, final Nil<?>... inTypes)
	{
		Object op = matchHelper(env, opName, ALL_FUNCTIONS.get(inTypes.length),
			outType, inTypes);
		if (op instanceof Producer) {
			return new Arity0AsN<>((Producer<O>) op);
		}
		else if (op instanceof Function) {
			return new Arity1AsN<>((Function<Object, O>) op);
		}
		else if (op instanceof BiFunction) {
			return new Arity2AsN<>((BiFunction<Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity3) {
			return new Arity3AsN<>((Functions.Arity3<Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity4) {
			return new Arity4AsN<>((Functions.Arity4<Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity5) {
			return new Arity5AsN<>((Functions.Arity5<Object, Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity6) {
			return new Arity6AsN<>((Functions.Arity6<Object, Object, Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity7) {
			return new Arity7AsN<>((Functions.Arity7<Object, Object, Object, Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity8) {
			return new Arity8AsN<>((Functions.Arity8<Object, Object, Object, Object, Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity9) {
			return new Arity9AsN<>((Functions.Arity9<Object, Object, Object, Object, Object, Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity10) {
			return new Arity10AsN<>((Functions.Arity10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity11) {
			return new Arity11AsN<>((Functions.Arity11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity12) {
			return new Arity12AsN<>((Functions.Arity12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity13) {
			return new Arity13AsN<>((Functions.Arity13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity14) {
			return new Arity14AsN<>((Functions.Arity14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O>) op);
		}
		else if (op instanceof Functions.Arity15) {
			return new Arity15AsN<>((Functions.Arity15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O>) op);
		}
		return new Arity16AsN<>((Functions.Arity16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O>) op);
	}

	@SuppressWarnings({ "unchecked" })
	private static <T> T matchHelper(final OpEnvironment env, final String opName,
		final Class<T> opClass, final Nil<?> outType, final Nil<?>... inTypes)
	{
		final Type[] types = new Type[inTypes.length + 1];
		for (int i = 0; i < inTypes.length; i++)
			types[i] = inTypes[i].getType();
		types[types.length - 1] = outType.getType();
		final Type specialType = Types.parameterize(opClass, types);
		return (T) env.op(opName, Nil.of(specialType), inTypes, outType);
	}

	@SuppressWarnings({ "unchecked" })
	private static <T> T matchHelper(final OpEnvironment env, final String opName, final Hints hints,
		final Class<T> opClass, final Nil<?> outType, final Nil<?>... inTypes)
	{
		final Type[] types = new Type[inTypes.length + 1];
		for (int i = 0; i < inTypes.length; i++)
			types[i] = inTypes[i].getType();
		types[types.length - 1] = outType.getType();
		final Type specialType = Types.parameterize(opClass, types);
		return (T) env.op(opName, Nil.of(specialType), inTypes, outType, hints);
	}

	/**
	 * A 3-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity3<I1, I2, I3, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity3<I1, I2, I3, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3) -> after.apply(apply(in1, in2, in3));
		}
	}

	/**
	 * A 4-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity4<I1, I2, I3, I4, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity4<I1, I2, I3, I4, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4) -> after.apply(apply(in1, in2, in3, in4));
		}
	}

	/**
	 * A 5-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity5<I1, I2, I3, I4, I5, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity5<I1, I2, I3, I4, I5, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5) -> after.apply(apply(in1, in2, in3, in4, in5));
		}
	}

	/**
	 * A 6-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity6<I1, I2, I3, I4, I5, I6, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity6<I1, I2, I3, I4, I5, I6, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6) -> after.apply(apply(in1, in2, in3, in4, in5, in6));
		}
	}

	/**
	 * A 7-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <I7> the type of argument 7 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity7<I1, I2, I3, I4, I5, I6, I7, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @param in7 function argument 7
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity7<I1, I2, I3, I4, I5, I6, I7, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7) -> after.apply(apply(in1, in2, in3, in4, in5, in6, in7));
		}
	}

	/**
	 * A 8-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <I7> the type of argument 7 to the function
	 * @param <I8> the type of argument 8 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity8<I1, I2, I3, I4, I5, I6, I7, I8, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @param in7 function argument 7
		 * @param in8 function argument 8
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity8<I1, I2, I3, I4, I5, I6, I7, I8, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8) -> after.apply(apply(in1, in2, in3, in4, in5, in6, in7, in8));
		}
	}

	/**
	 * A 9-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <I7> the type of argument 7 to the function
	 * @param <I8> the type of argument 8 to the function
	 * @param <I9> the type of argument 9 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity9<I1, I2, I3, I4, I5, I6, I7, I8, I9, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @param in7 function argument 7
		 * @param in8 function argument 8
		 * @param in9 function argument 9
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity9<I1, I2, I3, I4, I5, I6, I7, I8, I9, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9) -> after.apply(apply(in1, in2, in3, in4, in5, in6, in7, in8, in9));
		}
	}

	/**
	 * A 10-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <I7> the type of argument 7 to the function
	 * @param <I8> the type of argument 8 to the function
	 * @param <I9> the type of argument 9 to the function
	 * @param <I10> the type of argument 10 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity10<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @param in7 function argument 7
		 * @param in8 function argument 8
		 * @param in9 function argument 9
		 * @param in10 function argument 10
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity10<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10) -> after.apply(apply(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10));
		}
	}

	/**
	 * A 11-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <I7> the type of argument 7 to the function
	 * @param <I8> the type of argument 8 to the function
	 * @param <I9> the type of argument 9 to the function
	 * @param <I10> the type of argument 10 to the function
	 * @param <I11> the type of argument 11 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity11<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @param in7 function argument 7
		 * @param in8 function argument 8
		 * @param in9 function argument 9
		 * @param in10 function argument 10
		 * @param in11 function argument 11
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity11<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11) -> after.apply(apply(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11));
		}
	}

	/**
	 * A 12-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <I7> the type of argument 7 to the function
	 * @param <I8> the type of argument 8 to the function
	 * @param <I9> the type of argument 9 to the function
	 * @param <I10> the type of argument 10 to the function
	 * @param <I11> the type of argument 11 to the function
	 * @param <I12> the type of argument 12 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity12<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @param in7 function argument 7
		 * @param in8 function argument 8
		 * @param in9 function argument 9
		 * @param in10 function argument 10
		 * @param in11 function argument 11
		 * @param in12 function argument 12
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11, I12 in12);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity12<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11, I12 in12) -> after.apply(apply(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12));
		}
	}

	/**
	 * A 13-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <I7> the type of argument 7 to the function
	 * @param <I8> the type of argument 8 to the function
	 * @param <I9> the type of argument 9 to the function
	 * @param <I10> the type of argument 10 to the function
	 * @param <I11> the type of argument 11 to the function
	 * @param <I12> the type of argument 12 to the function
	 * @param <I13> the type of argument 13 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity13<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @param in7 function argument 7
		 * @param in8 function argument 8
		 * @param in9 function argument 9
		 * @param in10 function argument 10
		 * @param in11 function argument 11
		 * @param in12 function argument 12
		 * @param in13 function argument 13
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11, I12 in12, I13 in13);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity13<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11, I12 in12, I13 in13) -> after.apply(apply(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13));
		}
	}

	/**
	 * A 14-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <I7> the type of argument 7 to the function
	 * @param <I8> the type of argument 8 to the function
	 * @param <I9> the type of argument 9 to the function
	 * @param <I10> the type of argument 10 to the function
	 * @param <I11> the type of argument 11 to the function
	 * @param <I12> the type of argument 12 to the function
	 * @param <I13> the type of argument 13 to the function
	 * @param <I14> the type of argument 14 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity14<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @param in7 function argument 7
		 * @param in8 function argument 8
		 * @param in9 function argument 9
		 * @param in10 function argument 10
		 * @param in11 function argument 11
		 * @param in12 function argument 12
		 * @param in13 function argument 13
		 * @param in14 function argument 14
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11, I12 in12, I13 in13, I14 in14);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity14<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11, I12 in12, I13 in13, I14 in14) -> after.apply(apply(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14));
		}
	}

	/**
	 * A 15-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <I7> the type of argument 7 to the function
	 * @param <I8> the type of argument 8 to the function
	 * @param <I9> the type of argument 9 to the function
	 * @param <I10> the type of argument 10 to the function
	 * @param <I11> the type of argument 11 to the function
	 * @param <I12> the type of argument 12 to the function
	 * @param <I13> the type of argument 13 to the function
	 * @param <I14> the type of argument 14 to the function
	 * @param <I15> the type of argument 15 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity15<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @param in7 function argument 7
		 * @param in8 function argument 8
		 * @param in9 function argument 9
		 * @param in10 function argument 10
		 * @param in11 function argument 11
		 * @param in12 function argument 12
		 * @param in13 function argument 13
		 * @param in14 function argument 14
		 * @param in15 function argument 15
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11, I12 in12, I13 in13, I14 in14, I15 in15);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity15<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11, I12 in12, I13 in13, I14 in14, I15 in15) -> after.apply(apply(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15));
		}
	}

	/**
	 * A 16-arity specialization of {@link Function}.
	 *
	 * @param <I1> the type of argument 1 to the function
	 * @param <I2> the type of argument 2 to the function
	 * @param <I3> the type of argument 3 to the function
	 * @param <I4> the type of argument 4 to the function
	 * @param <I5> the type of argument 5 to the function
	 * @param <I6> the type of argument 6 to the function
	 * @param <I7> the type of argument 7 to the function
	 * @param <I8> the type of argument 8 to the function
	 * @param <I9> the type of argument 9 to the function
	 * @param <I10> the type of argument 10 to the function
	 * @param <I11> the type of argument 11 to the function
	 * @param <I12> the type of argument 12 to the function
	 * @param <I13> the type of argument 13 to the function
	 * @param <I14> the type of argument 14 to the function
	 * @param <I15> the type of argument 15 to the function
	 * @param <I16> the type of argument 16 to the function
	 * @param <O> the type of the output of the function
	 * @see Function
	 */
	@FunctionalInterface
	public interface Arity16<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, O> {

		/**
		 * Applies this function to the given arguments.
		 *
		 * @param in1 function argument 1
		 * @param in2 function argument 2
		 * @param in3 function argument 3
		 * @param in4 function argument 4
		 * @param in5 function argument 5
		 * @param in6 function argument 6
		 * @param in7 function argument 7
		 * @param in8 function argument 8
		 * @param in9 function argument 9
		 * @param in10 function argument 10
		 * @param in11 function argument 11
		 * @param in12 function argument 12
		 * @param in13 function argument 13
		 * @param in14 function argument 14
		 * @param in15 function argument 15
		 * @param in16 function argument 16
		 * @return the function output
		 */
		O apply(I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11, I12 in12, I13 in13, I14 in14, I15 in15, I16 in16);

		/**
		 * Returns a composed function that first applies this function to its
		 * input, and then applies the {@code after} function to the result. If
		 * evaluation of either function throws an exception, it is relayed to the
		 * caller of the composed function.
		 *
		 * @param <O2> the type of output of the {@code after} function, and of the
		 *          composed function
		 * @param after the function to apply after this function is applied
		 * @return a composed function that first applies this function and then
		 *         applies the {@code after} function
		 * @throws NullPointerException if after is null
		 */
		default <O2> Arity16<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, I11, I12, I13, I14, I15, I16, O2> andThen(Function<? super O, ? extends O2> after)
		{
			Objects.requireNonNull(after);
			return (I1 in1, I2 in2, I3 in3, I4 in4, I5 in5, I6 in6, I7 in7, I8 in8, I9 in9, I10 in10, I11 in11, I12 in12, I13 in13, I14 in14, I15 in15, I16 in16) -> after.apply(apply(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16));
		}
	}

	public interface ArityN<O> {

		O apply(Object... ins);

		Object getOp();
	}

	protected static class Arity0AsN<O> implements ArityN<O> {

		Producer<O> func;

		public Arity0AsN(Producer<O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.create();
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity1AsN<O> implements ArityN<O> {

		Function<Object, O> func;

		public Arity1AsN(Function<Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity2AsN<O> implements ArityN<O> {

		BiFunction<Object, Object, O> func;

		public Arity2AsN(BiFunction<Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity3AsN<O> implements ArityN<O> {

		Functions.Arity3<Object, Object, Object, O> func;

		public Arity3AsN(Functions.Arity3<Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity4AsN<O> implements ArityN<O> {

		Functions.Arity4<Object, Object, Object, Object, O> func;

		public Arity4AsN(Functions.Arity4<Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity5AsN<O> implements ArityN<O> {

		Functions.Arity5<Object, Object, Object, Object, Object, O> func;

		public Arity5AsN(Functions.Arity5<Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity6AsN<O> implements ArityN<O> {

		Functions.Arity6<Object, Object, Object, Object, Object, Object, O> func;

		public Arity6AsN(Functions.Arity6<Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity7AsN<O> implements ArityN<O> {

		Functions.Arity7<Object, Object, Object, Object, Object, Object, Object, O> func;

		public Arity7AsN(Functions.Arity7<Object, Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5], ins[6]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity8AsN<O> implements ArityN<O> {

		Functions.Arity8<Object, Object, Object, Object, Object, Object, Object, Object, O> func;

		public Arity8AsN(Functions.Arity8<Object, Object, Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5], ins[6], ins[7]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity9AsN<O> implements ArityN<O> {

		Functions.Arity9<Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func;

		public Arity9AsN(Functions.Arity9<Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5], ins[6], ins[7], ins[8]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity10AsN<O> implements ArityN<O> {

		Functions.Arity10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func;

		public Arity10AsN(Functions.Arity10<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5], ins[6], ins[7], ins[8], ins[9]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity11AsN<O> implements ArityN<O> {

		Functions.Arity11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func;

		public Arity11AsN(Functions.Arity11<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5], ins[6], ins[7], ins[8], ins[9], ins[10]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity12AsN<O> implements ArityN<O> {

		Functions.Arity12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func;

		public Arity12AsN(Functions.Arity12<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5], ins[6], ins[7], ins[8], ins[9], ins[10], ins[11]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity13AsN<O> implements ArityN<O> {

		Functions.Arity13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func;

		public Arity13AsN(Functions.Arity13<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5], ins[6], ins[7], ins[8], ins[9], ins[10], ins[11], ins[12]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity14AsN<O> implements ArityN<O> {

		Functions.Arity14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func;

		public Arity14AsN(Functions.Arity14<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5], ins[6], ins[7], ins[8], ins[9], ins[10], ins[11], ins[12], ins[13]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity15AsN<O> implements ArityN<O> {

		Functions.Arity15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func;

		public Arity15AsN(Functions.Arity15<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5], ins[6], ins[7], ins[8], ins[9], ins[10], ins[11], ins[12], ins[13], ins[14]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

	protected static class Arity16AsN<O> implements ArityN<O> {

		Functions.Arity16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func;

		public Arity16AsN(Functions.Arity16<Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, O> func) {
			this.func = func;
		}

		@Override
		public O apply(Object... ins) {
			return func.apply(ins[0], ins[1], ins[2], ins[3], ins[4], ins[5], ins[6], ins[7], ins[8], ins[9], ins[10], ins[11], ins[12], ins[13], ins[14], ins[15]);
		}

		@Override
		public Object getOp() {
			return func;
		}

	}

}
