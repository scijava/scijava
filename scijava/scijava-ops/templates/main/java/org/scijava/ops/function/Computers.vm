/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.ops.function;

import com.google.common.collect.BiMap;
import com.google.common.collect.ImmutableBiMap;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.scijava.ops.OpService;
import org.scijava.types.Nil;
import org.scijava.param.Mutable;
import org.scijava.types.Types;

/**
 * Container class for computer-style functional interfaces at various
 * <a href="https://en.wikipedia.org/wiki/Arity">arities</a>.
 * <p>
 * A computer has functional method {@code compute} with a number of arguments
 * corresponding to the arity, plus an additional argument for the preallocated
 * output to be populated by the computation.
 * </p>
 * <p>
 * Each computer interface implements a corresponding {@link Consumer}-style
 * interface (see {@link Consumers}) with arity+1; the consumer's {@code accept}
 * method simply delegates to {@code compute}. This pattern allows computer ops
 * to be used directly as consumers as needed.
 * </p>
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class Computers {

	private Computers() {
		// NB: Prevent instantiation of utility class.
	}

	// -- BEGIN TEMP --

	/**
	 * All known computer types and their arities. The entries are sorted by
	 * arity, i.e., the {@code i}-th entry has an arity of {@code i}.
	 */
	public static final BiMap<Class<?>, Integer> ALL_COMPUTERS;

	static {
		final Map<Class<?>, Integer> computers = new HashMap<>();
#foreach($arity in $arities)
		computers.put(Arity${arity}.class, $arity);
#end
		ALL_COMPUTERS = ImmutableBiMap.copyOf(computers);
	}

	/**
	 * @return {@code true} if the given type is a {@link #ALL_COMPUTERS known}
	 *         computer type, {@code false} otherwise. <br>
	 *         Note that only the type itself and not its type hierarchy is
	 *         considered.
	 * @throws NullPointerException If {@code type} is {@code null}.
	 */
	public static boolean isComputer(Type type) {
		return ALL_COMPUTERS.containsKey(Types.raw(type));
	}

#foreach($arity in [0..$maxArity])
	@SuppressWarnings("unchecked")
	public static $generics.call($arity) $computerArity.call($arity)$generics.call($arity) match(final OpService ops, final String opName, $matchParams.call($arity))
	{
		return matchHelper(ops, opName, ${computerArity.call($arity)}.class, $nilArgs.call($arity));
	}

#end
	@SuppressWarnings({ "unchecked" })
	private static <T> T matchHelper(final OpService ops, final String opName, final Class<T> opClass, final Nil<?> outType, final Nil<?>... inTypes)
	{
		final Type[] types = new Type[inTypes.length + 1];
		for (int i = 0; i < inTypes.length; i++)
			types[i] = inTypes[i].getType();
		types[types.length - 1] = outType.getType();
		final Type specialType = Types.parameterize(opClass, types);
		final Nil<?>[] nils = new Nil[inTypes.length + 1];
		System.arraycopy(inTypes, 0, nils, 0, inTypes.length);
		nils[nils.length - 1] = outType;
		return (T) ops.op(opName, Nil.of(specialType), nils, outType);
	}

	// -- END TEMP --
#foreach($arity in $arities)
#set($rawClass = "Arity$arity")
#set($genericParams = $generics.call($arity))
#set($gClass = "$rawClass$genericParams")

	@FunctionalInterface
	public interface $gClass extends
		$consumerArity.call($arity)$genericParams
	{

		void compute($computeParams.call($arity));

		@Override
		default void accept($acceptParams.call($arity))
		{
			compute($computeArgs.call($arity));
		}
	}
#end##foreach($arity)
}
